---
title: "STEAMcpp Vignette"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{STEAMcpp Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(STEAMcpp)
library(dplyr)
```

> STEAM VIGNETTE: MAKE NEW VIGNETTE ONCE WE FIGURE OUT WORKFLOW!!!

------------------------------------------------------------------------

# Introduction

# Installation

## Bioconductor

## GitHub

# Required Data Format (come up with better name?)

Grinde et al. (2019) proposed two approaches for estimating genome-wide significance thresholds for admixture mapping studies: Analytic Approximation (Section 4.2) and Test Statistic Simulation (Section 4.3). 

To run either approach, we first need to:

**Step 1:** Create a `map` file containing, at minimum, the chromosome number and genetic position (in centimorgans) of each marker being tested.
   
   * **NOTE:** If you inferred local ancestry using a program that performs calling within windows (e.g., RFMix), we recommend that you include just a single marker per window in this map file.
   
Here is an example of a map file, `example_map`, available in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data):
```{r}
## first 6 rows of example_map ##
head(example_map)
```

**Step 2:** Estimate the admixture proportions for each individual and store them in an `n`-by-`K` matrix, where `n` is the number of admixed individuals and `K` is the number of ancestral populations.
   
   * There are various ways to calculate these proportions, one of which is to calculate the genome-wide average local ancestry for each individual.
   
Below is an example of a matrix of admixture proportions, `example_props`, available in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data). This matrix contains the admixture proportions for `n = 1000` admixed individuals and `K = 2` ancestral populations:
```{r}
head(example_props)
sample_n(example_props, 6)
```

Similarly, `example_props_K3` in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data) is an example admixture proportions matrix for `n = 1000` admixed individuals and `K = 3` ancestral populations:
```{r}
head(example_props_K3)
```


**Step 3:** Estimate g, the number of generations since admixture.
   
   * We recommend that you use STEAM for this step. **NOTE:** Using this approach requires that you calculate the observed correlation of local ancestry at pairs of loci in your data. For more details, please see Section 4.1 below.

# Main Functions

The STEAMcpp package contains the following main functions:

| Function | Description |
|----------|----------|
| `get_g` | estimate the number of generations since admixture |
| `get_thresh_analytic` | for K = 2 populations, compute genome-wide significance threshold for admixture mapping |
| `get_thresh_simstat` | for K = 2 or K = 3 populations, compute genome-wide significance threshold for admixture mapping |

`g`, the number of generations since admixture, is a required parameter for both `get_thresh_analytic` and `get_thresh_simstat`. `g` can be quickly estimated using the `get_g` function using the observed correlation of local ancestry at pairs of loci in the data. This method is described in Section 4.1 below.

## Estimating g (get_g)

The theoretical results in Grinde et al. (2019) demonstrate that the number of generations since admixture controls the rate of decay of local ancestry correlation curves in admixed populations. *Lemma 1* provides a closed form expression for the expected correlation of local ancestry at a pair of loci, which depends on the recombination fraction between those loci, the distribution of admixture proportions, and the generations since admixture. We use this result to motivate a non-linear least squares procedure to estimate the number of generations since admixture (`g`) from observed local ancestry correlation. 

Estimating `g` from our observed data---rather than relying on estimates from external genetic or historical studies---allows us to appropriately capture the correlation structure in our own data, which is critical for our multiple testing procedures.

**To use STEAM to estimate `g`, we must first calculate the observed correlation of local ancestry at pairs of loci in our data.** Calculating this correlation for all possible pairs of loci is not necessary; using a representative, thinned subset of markers will suffice. However, correlation should be calculated for all possible pairs of ancestral components:

* In an admixed population with 2 ancestral populations (e.g., African, European), there are three possible pairs of ancestral components (AFR at both loci, EUR at both loci, AFR at one locus and EUR at the other locus).

* In an admixed population with 3 ancestral populations (e.g., African, European, Native American), there are six possible pairs of ancestral components (AFR at both loci, EUR at both loci, NAM at both loci, AFR at one and EUR at the other, AFR at one and NAM at the other, EUR at one and NAM at the other).

Store this local ancestry correlation in a data frame with three columns, as in the following examples (available in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data)):

```{r}
## 2 ancestral populations ##
head(example_corr)
```

```{r}
## 3 ancestral populations ##
head(example_corr_K3)
```

### Calculating Observed Local Ancestry Correlation using STEAM

You are free to calculate this local ancestry correlation however you please. One option (if you are studying an admixed population with `K = 3` ancestral populations) is to use the functions `get_corr_chr` and `combine_corr_chr` contained in this package:

**Step 1:** Convert local ancestry calls into SeqArray GDS files, with one file per ancestral population and chromosome (i.e., 'chr22_afr.gds' contains local ancestry calls for chromosome 22, where alleles are coded such that 1 = allele inherited from African ancestors, 0 = allele inherited from some other ancestral population).

* **NOTE:** if you first convert your local ancestry calls into VCF files, with one file per chromosome and ancestral population, then you can use `vcf2gds.py` in the [UW GAC TOPMed analysis pipeline](https://github.com/UW-GAC/analysis_pipeline) to convert to GDS files.

**Step 2:** Run `get_corr_chr` for each chromosome:

```{r eval = FALSE}
# set up list to store results
corr.list <- list()

# loop through chromosomes
# NOTE: we recommend that each chromosome be analyzed separately (e.g., on 
# distinct compute nodes) and results saved, then combined later, rather 
# than analyzing all chromosomes in a single R session
for(i in 1:22){
  # set up file names
  afr.gds <- paste0('chr', i, '_afr.gds')
  eur.gds <- paste0('chr', i, '_eur.gds')
  nam.gds <- paste0('chr', i, '_nam.gds')
  # run get_corr_chr
  corr.list[[i]] <- get_corr_chr(chrom = i, map = example_map, 
        pop1.gds = afr.gds, pop2.gds = eur.gds, pop3.gds = nam.gds)
  # print update
  cat('done with chromosome', i, '\n')
}
```

**Step 3:** Run `combine_corr_chr` to combine results across all chromosomes and store as a data frame in the desired format:

```{r eval = FALSE}
# combine results across chromosomes
corr_K3 <- combine_corr_chr(corr.list)
```

This data frame should include three columns, named `theta`, `corr`, and `anc` (column order does not matter, but the column names do!):

* `theta`: recombination fraction between loci
* `corr`: correlation between those local ancestry components at that pair of loci
* `anc`: indices of ancestral compoments being compared at the two loci (e.g., `1_1`, `1_2`)

### Using `get_g`

Once we have this local ancestry correlation, we use non-linear least squares to estimate the value of `g` that provides the best fit to the equation $\text{Corr} = a + b \times (1-\theta)^g$ (see Grinde et al. (2019) for more details):

```{r}
## 2 ancestral populations ##
get_g(example_corr)
```

```{r}
## 3 ancestral populations ##
get_g(example_corr_K3)
```

**NOTE:** in these examples, we simulated local ancestry correlation for admixed populations with `g = 6` (2 ancestral populations) and `g = 10` (3 ancestral populations). In both cases, the estimated g turns out very close to the truth: 5.97 and 9.96, respectively.

## Analytic Approximation (get_thresh_analytic)

## Test Statistic Simulation (get_thresh_simstat)

### K = 2 populations

### K = 3 populations

# Session Info

```{r}
sessionInfo()
```


# References



------------------------------------------------------------------------

> END OF STEAM VIGNETTE, EVERYTHING BELOW IS ZUOFU'S (AND MINE A LITTLE BIT)

# Introduction

## An Introduction to the STEAM Package

The STEAM (Significance Threshold Estimation for Admixture Mapping) package is a package for estimating genome-wide significance thresholds for admixture mapping studies. STEAMcpp is a working version of the STEAM package developed by Grinde et. al in 2019 with core functions implemented with Rcpp, which decreases the user's wall-clock waiting time for some functions.

When thinking about finding the genetic variant that causes certain diseases or traits in genome-wide association studies (GWAS) data, a traditional approach is to use marginal regression to step over the genome and perform a hypothesis test at each location. However, with the large number of hypothesis tests in genomic data, we are often faced with the issue of multiple testing. Traditional multiple testing corrections such as Bonferroni correction (Bonferroni, 1936) tend to yield conservative thresholds with respect to controlling for family-wise error rate (FWER). The significance threshold $p < 5*10^{-8}$ has increasingly emerged as the significance threshold commonly used in genome-wide association studies (Jannot et. al, 2015). However, the prevalent significant threshold does not always ensure the best trade-off between Type I and Type II errors.

Our goal with STEAMcpp is to find an appropriate, less conservative significance threshold $p$ that controls the family-wise error rate. 

## Theoretical Background

> add more? not needed? look at other vignettes and see what they do

The theoretical results implemented in the package are proposed in the following article.

Grinde, K., Brown, L., Reiner, A., Thornton, T., & Browning, S. "Genome-wide significance thresholds for admixture mapping studies." The American Journal of Human Genetics 104 (2019), 454-465. https://doi.org/10.1016/j.ajhg.2019.01.008.

&nbsp;

In Grinde et. al (2019), two approaches for estimating genome-wide significance threshold for admixture mapping studies were proposed:

- **Analytic Approximation**: applicable to admixed populations with 2 ancestral populations
- **Test Statistic Simulation**: applicable to admixed populations with 2 or more ancestral populations (STEAM supports at most 3 ancestries)

# Setup

## Installation

> WILL NEED TO UPDATE IF/WHEN SUBMITTING TO BIOCONDUCTOR!!!

To install the STEAMcpp package from GitHub, run the following code in your R console:

```{r eval = FALSE}
## install.packages("devtools")
library(devtools)
install_github('GrindeLab/STEAMcpp', build_vignettes = TRUE)
```

To install the STEAMcpp package from BioConductor, use the following code in your R console:

```{r eval = FALSE}
# CODE PLACEHOLDER!!
```

## Required Data

> FIX FORMATTING!!!

To run either approach, we need to do some preparations steps:

1. Create a `map` file containing, at minimimum, the chromosome number and genetic position (in centimorgans) of each marker being tested.
    * NOTE: If you inferred local ancestry using a program that performs calling within windows (e.g., RFMix), we recommend that you include just a single marker per window in this map file.
  
2. Estimate the admixture proportions for each individual and store them in a `n`-by-`K` matrix, where `n` is the number of admixed individuals and `K` is the number of ancestral populations.
    * There are various ways to calculate these proportions, one of which is to calculate the genome-wide average local ancestry for each individual.
  
3. Estimate `g`, the number of generations since admixture.
    * We recommend that you use STEAM for this step. NOTE: using this approach requires that you calculate the observed correlation of local ancestry at pairs of loci in your data. For more details, see the "Estimating the Number of Generations..." section below.
  
## Example: 2 ancestral origins

For this example with 2 ancestral origins, we can use either analytic approximation or test statistic simulation to obtain the significance threshold. The analytic approximation is faster of the two options.

Step 1: Suppose we have markers spaced every 0.2 cM across 22 chromosomes. An example of this map file is `example_map` provided by the package, which stores the information about genetic position and chromosome for each marker.

```{r}
head(example_map)
```


## References

Bonferroni, C. (1936). Teoria statistica delle classi e calcolo delle probabilita. Pubblicazioni del R Istituto Superiore di Scienze Economiche e Commericiali di Firenze, 8, 3-62.

Jannot, A. S., Ehret, G., & Perneger, T. (2015). P< 5× 10− 8 has emerged as a standard of statistical significance for genome-wide association studies. Journal of clinical epidemiology, 68(4), 460-465.

